package family_fun_pack.modules;

import net.minecraft.client.Minecraft;
import net.minecraft.network.EnumPacketDirection;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.CPacketConfirmTeleport;
import net.minecraft.network.play.server.SPacketPlayerPosLook;
import net.minecraft.network.play.server.SPacketRespawn;
import net.minecraftforge.fml.relauncher.SideOnly;
import net.minecraftforge.fml.relauncher.Side;

import io.netty.buffer.ByteBuf;

import family_fun_pack.FamilyFunPack;
import family_fun_pack.network.NetworkHandler;
import family_fun_pack.network.PacketListener;

import java.util.Set;

/* Stay invulnerable after going through portals, ignore facing direction reset from server
 * You won't be able to move though */

@SideOnly(Side.CLIENT)
public class PortalInvulnerabilityModule extends Module implements PacketListener {

  private boolean currently_invulnerable;
  private int label_id;
  private int last_teleport_id;

  public PortalInvulnerabilityModule() {
    super("Portal invulnerability", "Be invulnerable after going through a portal");
    this.currently_invulnerable = false;
    this.last_teleport_id = -1;
    this.label_id = -1;
  }

  public void onDisconnect() {
    this.currently_invulnerable = false;
    this.last_teleport_id = -1;
    if(this.label_id >= 0) FamilyFunPack.getOverlay().removeLabel(this.label_id);
    this.label_id = -1;
  }

  protected void enable() {
    FamilyFunPack.getNetworkHandler().registerListener(EnumPacketDirection.CLIENTBOUND, this, 47, 53);
    FamilyFunPack.getNetworkHandler().registerListener(EnumPacketDirection.SERVERBOUND, this, 0);
  }

  protected void disable() {
    FamilyFunPack.getNetworkHandler().unregisterListener(EnumPacketDirection.CLIENTBOUND, this, 47, 53);
    FamilyFunPack.getNetworkHandler().unregisterListener(EnumPacketDirection.SERVERBOUND, this, 0);
    if(this.last_teleport_id != -1) {
      FamilyFunPack.getNetworkHandler().sendPacket(new CPacketConfirmTeleport(this.last_teleport_id));
    }
    this.onDisconnect();
  }

  public Packet<?> packetReceived(EnumPacketDirection direction, int id, Packet<?> packet, ByteBuf in) {
    if(direction == EnumPacketDirection.CLIENTBOUND) {
      switch(id) {
        case 47: // SPacketPlayerPosLook
          {
            if(this.currently_invulnerable) {
              if(! Minecraft.getMinecraft().player.isRiding()) { // don't disturb while riding
                SPacketPlayerPosLook old = (SPacketPlayerPosLook) packet;
                Set<SPacketPlayerPosLook.EnumFlags> flags = old.getFlags();
                flags.add(SPacketPlayerPosLook.EnumFlags.Y_ROT);
                flags.add(SPacketPlayerPosLook.EnumFlags.X_ROT);
                this.last_teleport_id = old.getTeleportId();
                return new SPacketPlayerPosLook(old.getX(), old.getY(), old.getZ(), 0, 0, flags, this.last_teleport_id);
              }
              return null;
            }
          }
          break;
        case 53: // SPacketRespawn
          {
            if(! this.currently_invulnerable) {
              SPacketRespawn respawn = (SPacketRespawn) packet;
              this.currently_invulnerable = (respawn.getDimensionID() != Minecraft.getMinecraft().player.dimension);
              if(this.currently_invulnerable) {
                this.label_id = FamilyFunPack.getOverlay().addLabel("Invulnerable");
              }
            }
          }
          break;
      }
    } else if(id == 0 && this.currently_invulnerable) return null;

    return packet;
  }

}
